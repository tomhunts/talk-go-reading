## 33 | 关于 Linux 网络，你必须知道这些

### 网络模型

#### OSI七层模型

+ 应用层：为应用程序提供统一的接口
+ 表示层：把数据转换成兼容接收系统的格式
+ 会话层：维护计算机之间的通信连接
+ 传输层：负责为数据加上传输标头，形成数据包
+ 网络层：数据的路由和转发
+ 数据链路层：负责MAC寻址、错误侦测和改错
+ 物理层：负责在屋里网络中传输数据帧

比如说到的七层和四层负载均衡，对应的就是 OSI模型中的应用层和传输层。

#### TCP/IP 四层模型

+ 应用层：向用户提供一组应用程序，比如HTTP、FTP等  对应七层中的（应用层，表示层，会话层）
+ 传输层：端到端的通信，比如TCP、UDP等		对应七层中的（传输层）
+ 网络层：负责网络包的封装、寻址和路由比如IP、ICMP等  对应七层中的（网络层）
+ 网络接口层：负责网络包在物理网络中的传输，比如MAC寻址、错误侦测以及通过网卡传输网络帧等  对应七层中的（数据链路层，物理层）

网络接口配置的最大传输单元MTU，规定了最大的IP包大小，在常见的以太网中，MTU默认值是1500，如果超过了MTU大小，就会在网络层分片，显然MTU越大，需要的分包也就越少，网络吞吐能力也越好

网卡是发送和接收网络包的基本设备，在系统启动过程中，网卡通过内核这怒该的网卡驱动程序注册到系统中，而在网络收发过程中，内核通过终端跟网卡进行交流，所以网卡硬中断只处理最核心的网卡数据读取或发送，而协议栈中的大部分逻辑，都会放到软中断中处理

### Liunx网络收发流程

#### 网络包的接收流程

+ 网络帧到大网卡后，网卡通过DMA方式，把这个网络包放到收包队列中，通过硬中断，告诉中断处理程序已经收到了网络包
+ 网卡中断处理处理程序回味网络帧分配内核数据结构（sk_buff），并将其拷贝到sk_buff缓冲区，之后通过软中断，通知内核收到新的网络帧
+ 内核协议栈从缓冲区取出网络帧，通过网络协议栈，从下到上逐层处理这个网络帧。
	+ 从链路层检查报文和方形，找到上层对应的协议类型，去掉帧头、帧尾，然后交给网络层
	+ 网络层取出IP头，判断网络报的下一步走向，当网络层确认这个包是要发送到本机后，就会取出上层协议的类型，去掉IP头，交由传输层处理
	+ 传输层取出TCP头或者UDP头后，根据 <源IP、源端口、目标IP、目标端口>四元组作为标识，找出对应的socket，并将数据拷贝到socket的接收缓存中

+ 应用程序使用socket接口，读取新接收到的数据

#### 网络包的发送流程

发送流程与接收流程刚好相反。
+ 应用程序调用socket API发送网络包，这是一个系统调用，会陷入到内核态的套接字层中，套接字层会把数据包放到socket发送缓冲区中
+ 网络协议栈从socket发送缓冲区中取出数据包，按照TCP/IP栈，从上到下逐层处理，比如L传输层和网络层，分别为其增加TCP头和IP头，执行路由查找确认下一跳的IP，并按照MTU大小进行分片
+ 分片后的网络包，发送到网络接口层，进行物理地址寻址，找到下一跳的MAC地址。然后添加帧头和帧尾，放到发包队列中，完成后，通过软中断通知驱动程序，发包队列中有新的网络帧需要发送，
+ 驱动程序通过DMA，从发包队列中读出网络帧，并通过物理网卡把他发送出去


#### 收发流程另一种解释
+  内核分配一个主内存地址段（DMA缓冲区)，网卡设备可以在DMA缓冲区中读写数据
+  当来了一个网络包，网卡将网络包写入DMA缓冲区，写完后通知CPU产生硬中断
+  硬中断处理程序锁定当前DMA缓冲区，然后将网络包拷贝到另一块内存区，清空并解锁当前DMA缓冲区，然后通知软中断去处理网络包。



### 性能指标

通常用带宽、吞吐量、延时、PPS等指标衡量网络的性能

+ 带宽：表示链路的最大传输速率，单位通常为b/s（比特/秒）
+ 吞吐量：表示单位时间内成功传输的数据量单位通常为b/s（比特/秒）或者B/s（字节/秒），它受带宽限制，而吞吐量/带宽,就是网络的使用率
+ 延迟：网络请求发出后，一直到收到远端响应，所需要的时间延迟。在不同场景中，指标有不同含义，建立连接需要的时间（TCP握手延时），又或者数据包往返需要的时间（比如RTT）
+ PPS：是 Packet Per Second（包 / 秒）的缩写，表示网络包为单位的传输速率，通常用来评估网络的转发能力，

除了这些还有，网络的可用性，并发连接数，丢包率，重传率等指标

### 查看网络配置

通常使用ifconfig或者ip命令查看，这俩基本差不多，建议使用ip，提供了更丰富的功能和更易用的接口

+ 网络接口的状态标志，在ifconfig输出中的RUNNING，或者ip输出中的LOWER_UP表示网卡已连接到交换机或者路由器汇总，如果看不到他们，通常表示网线被拔掉了
+ MTU的大小，默认是1500，根据网络架构的不同，可能需要调整数值大小
+ 网络接口IP的地址，子网，以及mac地址，这些都是必备的配置，必须正确
+ 网络收发的字节数、包数、错误数以及丢包情况，特别是TX和RX部分的errors、dropped、overruns、carrier以及collisions等指标不为0时。通常表示出现了网络I/O问题
	+ errors：发送错误的数据包数，比如检验错误，帧同步错误等
	+ dropped：表示丢弃的数据包数，即数据包已经收到了ring buffer，但因为内存不足等原因丢包
	+ overruns：超限数据包数，即网络I/O速度过快，导致ring buffer中的数据包来不及处理（队列满）导致的丢包
	+ carrier：carrirer错误的数据包数，比如双工模式不匹配，物理电缆出线问题等
	+ collisions：碰撞数据包数

### 套接字信息

通过netstat或者ss来查看套接字网络栈接口以及路由表的信息，推荐使用ss，性能更好

```sh

# head -n 3 表示只显示前面3行
# -l 表示只显示监听套接字
# -n 表示显示数字地址和端口(而不是名字)
# -p 表示显示进程信息
$ netstat -nlp | head -n 3
Active Internet connections (only servers)
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name
tcp        0      0 127.0.0.53:53           0.0.0.0:*               LISTEN      840/systemd-resolve

# -l 表示只显示监听套接字
# -t 表示只显示 TCP 套接字
# -n 表示显示数字地址和端口(而不是名字)
# -p 表示显示进程信息
$ ss -ltnp | head -n 3
State    Recv-Q    Send-Q        Local Address:Port        Peer Address:Port
LISTEN   0         128           127.0.0.53%lo:53               0.0.0.0:*        users:(("systemd-resolve",pid=840,fd=13))
LISTEN   0         128                 0.0.0.0:22               0.0.0.0:*        users:(("sshd",pid=1459,fd=3))
```
接收队列（Recv_Q）和发送队列（Send_Q）：如果他们不是0说明网络包有对接发生
当套接字处于连接状态时（Established）：
	+ Recv-Q 表示套接字缓冲还没有被应用程序取走的字节数（即接收队列长度，
	+ Send-Q 表示还没有被远端主机确认的字节数（即发送队列长度）。
当套接字在监听状态（Listening）时：
	+ Recv-Q 表示全连接队列的长度。
	+ 而 Send-Q 表示全连接队列的最大长度。
全连接：服务器收到了客户端的ack，完成了TCP三次握手，会把这个连接挪到全连接队列中，这些全连接中的套接字，还需要被accept（）系统调用取走，服务器材开始真正处理客户端请求
半连接：还没完成TCP三次握手的链接，链接只进行了一般，服务器接收到了客户端的SYN包后，就会把这个连接放到半连接队列中，然后再向客户端发送SYN+ACK包

### 协议栈统计信息

```sh
netstat -s
ss -s
```
### 网络吞吐和PPS

推荐使用sar命令 sar -n 可查看网络的统计信息，比如网络接口DEV，网络接口错误（EDEV）

```sh
root@app1401:/home/baodongying# sar -n DEV 1
Linux 3.10.0-327.el7.x86_64 (app1401.hv.sp.prd.bmsre.com) 	2020年06月23日 	_x86_64_	(2 CPU)

16时55分53秒     IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s
16时55分54秒      eth0     25.00      8.00      1.60      0.86      0.00      0.00      0.00
16时55分54秒        lo      0.00      0.00      0.00      0.00      0.00      0.00      0.00
```
+ rxpck/s 和 txpck/s 分别是接收和发送的 PPS，单位为包 / 秒
+ rxkB/s 和 txkB/s 分别是接收和发送的吞吐量，单位是 KB/ 秒
+ rxcmp/s 和 txcmp/s 分别是接收和发送的压缩数据包数，单位是包 / 秒
+ %ifutil 是网络接口的使用率，即半双工模式下为 (rxkB/s+txkB/s)/Bandwidth，而全双工模式下为 max(rxkB/s, txkB/s)/Bandwidth



