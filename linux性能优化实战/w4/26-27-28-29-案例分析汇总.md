## 26-27-28-29 | 案例分析汇总？

### 案例分析1:程序疯狂写日志到磁盘 

+ 通过top命令查看总体的使用情况，并针对发现的问题做个简单记录，比如发现某个CPU的iowait 超过了90%。同时针对内存，发现有大部分内存用到了缓存上

+ 之后通过iostat命令观察I/O的使用情况，观察%util列的磁盘使用情况超过了99%，以及w_await的写请求响应时间，超过了7秒多，以及请求队列长度aqu-sz超过了1100。猜测：超慢的响应时间和特长的请求队列长度。导致了磁盘的严重性能瓶颈

+ 通过pidstat加上-d参数，查找具体引起问题的进程，会发现除了相应的进程外还有两个进程(kworker和jdb2)的延迟，居然更大，其实kworker是一个内核线程，而jdb2是ext4文件系统中，用来保证数据完整性的内核线程，他们都是保证文件系统基本功能的内核线程。具体细节可不用管

+ 找到具体的进程号之后，通过strace -p 进程号  命令 追踪代码段。查问题

+ 通过lsof -p 进程号 查找对应进程都代开了哪些文件（这里文件不只是普通文件，还有目录，块设备，动态库，网络套接字等）

### 案例2：磁盘I/O延迟很高

问题：通过curl访问相应的接口发现接口长时间没有响应，之后在中断里输入简单的df命令，也要等好久才有输出

+ 通过top来整体观察，之后使用iostat来观察磁盘的I/O情况

+ 通过pidstat查看相应的进程情况

+ 如果通过strace 加上-f追踪多进程和多线程发现不了问题所在代码，可使用其他工具

+ filetop命令： 跟踪内核中文件的读写情况，并输出线程ID、读写大小、读写类型、以及文件名称

+ opensnoop命令：动态跟踪内核中的open系统调用，找到相应的文件路径


本例中问题：通过程序动态生成了一批文件用来临时存储数据，用完之后就会删除它们。

### 案例3：sql查询要15秒

问题：访问相应的web接口发现处理时间很长才返回

+ 首先通过top分析cpu情况：发现iowait超过了60%，而CPU的使用率不是很高

+ 发现iowait高之后，通过 iostat -d -x 1 命令查看相应的I/O输出情况

+ 之后通过pidstat -d 查找是哪些进程导致的I/O升高

+ 之后通过lsof命令查找对应进程打开的文件，发现了针对相应数据库表的操作

+ 链接数据库 通过show full processlist命令查看当前正在执行的sql语句

+ 通过Mysql内置的explain命令来分析相应的sql语句

+ 发现是没有添加索引导致，添加相应的索引后 正常

### 案例4：Redis响应严重延迟

问题：通过curl相应的web接口，发现接口调用花费了10秒钟

+ 首先通过top命令分析系统，发现相应cpu的iowait高达84%，而其他各个进程的cpu使用率都不高，得出还是iowait最有嫌疑

+ iostat命令查看I/O问题，发现每秒写数据也不高，同时I/O使用率也不高，排查下来，好像没有继续下面的思路了

+ 仔细分析，代码是通过redis读取数据慢，而在I/O中反映的却是写操作，现在来查看是哪个进程在执行写操作

+ 通过pidstat -d 1命令查看相应进程写操作情况，发现确实是redis-server进程在写

+ 通过strace命令跟踪进程号来分析问题

+ 通过lsof -p 分析问题，发现进程里有一个针对/data/appendonly.aof文件的写行为，通过这可知道这是redis的持久化配置导致。由此分析可能是持久化配置不合理导致的，查看持久化配置发现问题

+ 通过strace命令跟踪进程号分析

```sh
# -f表示跟踪子进程和子线程，-T表示显示系统调用的时长，-tt表示显示跟踪时间
$ strace -f -T -tt -p 9085
```
发现epoll_pwait、read、write、fdatasync调用都比较频繁。

也可以使用 -e命令指定 fdatasync命令查看相应的结果

```sh
strace -f -p 9085 -T -tt -e fdatasync
```
发现每隔10ms左右机油一次fdatasync调用

+ 对redis来说SADD是一个写操作，根据strace结果发现，每当GET返回good时，随后都会有一个SADD操作，这就导致了，命名是查询接口，redis却有大量的磁盘写


至此通过此案例发现了两个问题：
+ redis的配置汇总appendfsync是always导致了每次写操作都会触发fdatasync系统调用 导致问题
+ 应用程序在调用redis的SADD命令，这很有可能是不合理的使用缓存导致的，通过代码发现问题

### 拓展

+ 如果缓存使用内存过多，查找哪些占用了缓存 可使用 pcstat或者hcache

+ 平常使用pidstat -wut 1 既可以看上下文切换，又可以看cpu使用统计，还有各个线程

+ strace -p 3387 -f 2>&1 | grep write 可以追逐子线程，以及搜索系统写调用

+ lsof -p 传入的是进程号，如果传入线程号会导致命令失败

+ MYsql前缀选择算法：如何选择最优前缀保证索引的高性能：通过select count(distinct city)/count(*) from city_demo; 根据这个算出一个比例，然后 count(distinct left(city,3)) 把这个3逐渐的加大，一直到算出来的数值接近上面的比例

